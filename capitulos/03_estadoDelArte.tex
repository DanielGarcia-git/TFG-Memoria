\chapter{Estado del arte de la ingeniería inversa}
\label{cap:estadoDelArte}

\begin{flushright}
    \begin{minipage}[]{10cm}
        \emph{Sometimes, the best way to advance is in reverse}\\
    \end{minipage}\\

    Eldad Eilam, \textit{Reversing : secrets of reverse engineering}\\
\end{flushright}

\vspace{1cm}

% Corregido 01/01/2024
% TODO:daniel: Revisar El estado del arte de la ingeniería inversa

Antes de entrar en profundidad en el proyecto que en esta memoria se detalla me
gustaría introducir formalmente el concepto de ''ingeniería inversa'' o conocida
en el mundo de la informática como \textit{reverse engineering}. La ingeniería
inversa es el proceso de extraer conocimiento o el diseño por cualquier cosa que 
el humano haya hecho. Por lo tanto, no es un concepto que solo acotemos dentro de
la ingeniería informática, sino que se puede aplicar a cualquier proceso ingenieril.
De hecho, este proceso es bastante similar al método científico, con la única diferencia
que la ingeniería inversa solo se aplica sobre cosas que ha hecho un humano y en el
método científico lo aplicamos en fenómenos naturales.

La ingeniería inversa es usada normalmente para obtener conocimiento desconocido o la
filosofía del diseño cuando esta información no está disponible, ya sea porque su
propietario ha decidido no compartirla o porque esta información está perdida o 
destruida. \cite{alma991003132729706711}

La ingeniería inversa aplicada al \textit{software} es el mismo concepto, pero aplicada
a programa en su formato binario, con el objetivo de obtener el código fuente en un
lenguaje de programación concreto y así poder obtener información como el diseño del
programa. De hecho, la ingeniería inversa aplicada al \textit{software} requiere
diferentes artes: descifrado de códigos, resolución de puzzles, programación y análisis
lógico.

Las aplicaciones de la ingeniería inversa son muy variadas, pero podemos destacar dos
categorías: seguridad y desarrollo de \textit{software}.

Sus aplicaciones en seguridad son muy variadas, pero normalmente se le relaciona con
\textit{malware}, algoritmos criptográficos y auditorias sobre binarios.

Dentro del mundo del \textit{software} malicioso vemos que la ingeniería inversa se
utiliza en dos aspectos diferentes. Desde el punto de perspectiva de los que desarrollan
\textit{software} malicioso utilizan la ingeniería inversa para poder encontrar
vulnerabilidades en los programas que quieren infectar. En cambio, desde el punto de vista
de los desarrolladores de antivirus, utilizan la ingeniería inversa para poder diseccionar
y analizar cada programa malicioso.

También se puede aplicar ingeniería inversa sobre algoritmos criptográficos, de tal manera
que podamos averiguar que tan seguro es ese mensaje encriptado, o incluso en caso de utilizar
algoritmos basados en llaves, en los cuales la especificación del algoritmo de encriptación
es conocido, pero que cada implementación específica puede variar, encontrar vulnerabilidades
en estos algoritmos.

Y por último, también la ingeniería inversa se aplica para realizar auditorias sobre binarios,
de tal manera que podamos detectar si un programa es seguro o no, encontrar sus vulnerabilidades
para poder corregirlas. Por lo tanto, cuanto mejores sean las herramientas de ingeniería inversa
que se apliquen, podremos encontrar con mucha más eficacia problemas de seguridad en \textit{software}
propietario.

Como he mencionado con anterioridad, la ingeniería inversa también se aplica dentro del desarrollo
de \textit{software}, estas aplicaciones las podemos encontrar en diferentes etapas, por ejemplo
cuando disponemos de un \textit{software} propietario y a documentación es escasa, el uso de
herramientas de ingeniería inversa nos podrían ayudar a conseguir más interoperabilidad con
el \textit{software} propietario.

Otras de las aplicaciones, y que he mencionado anteriormente, es el comprobar la robustez y calidad
de un programa informático, de tal manera que se pueda corregir posibles problemas de seguridad o
problemas funcionales.

Una vez introducido el concepto de ingeniería inversa de manera general, creo que es interesante
contestar a la siguiente pregunta: \textbf{¿Es la ingeniería inversa legal?}

Como hemos podido ver en los párrafos anteriores, muchas veces aplicamos ingeniería inversa sobre
un \textit{software} propietario, algunos con fines de conocer vulnerabilidades y corregirlas
y otros con fines de encontrar estas vulnerabilidades para tener un punto de ataque. En
otras palabras, la legalidad de la aplicación de ingeniería inversa dependerá mucho
de para que lo estamos aplicando, la finalidad, y sobre que lo estamos aplicando.

En conclusión, la ingeniería inversa es un proceso complejo y que requiere de muchas habilidades 
y que sus aplicaciones son muy variadas, desde auditorias sobre binarios hasta mejorar
la interoperabilidad de dos programas.

\section{Ética y legalidad}
\label{sec:etica_legalidad}

% Corregido 01/01/2024
% TODO:daniel: Revisar Ética y legalidad

Cuando inicie este proyecto, una de las primeras peguntas que me hice fue: si conseguimos
generar código a partir de un ejecutable, ¿sería legal? ¿Sería ético? ¿Qué implicaciones
legales y éticas tendría?

Creo que es importante reflexionar e indagar más sobre este asunto, ya que, como estudiante
de ingeniería, uno a de ser consciente de las repercusiones de los proyectos que desarrolla y
de las implicaciones que tiene en la sociedad. Así mismo, también es crucial saber que las
técnicas aplicadas en este proyecto son legales o no.

Para poder responder a estas preguntas, me gustaría empezar por la ética. Creo que muchos, cuando
lean esta memoria, se sentirán identificados cuando de pequeños cogíamos juguetes o electrodomésticos
para desmontarlos y poder ver como funcionaban. En aquel momento, desconocíamos que lo que estábamos
haciendo era ingeniería inversa, ¿pero quiere decir esto que lo que hacíamos era ilegal o inmoral?

El ser humano, por naturaleza, es curioso y siempre ha tenido la necesidad de entender como funcionan
las cosas, es algo innato y que nos ha ayudado a tener las tecnologías que hoy en día tenemos. Por lo tanto,
creo que lo importante es con qué finalidad se hace. Si lo hacemos con la finalidad de aprender y entender
como funcionan las cosas para poder crear nuevos productos o mejorar los existentes, creo que es algo
positivo.

Por dar un ejemplo ilustrativo, en los años 80's IBM dominaba el mercado de los ordenadores personales
con su IBM PC gracias a su BIOS, e IBM se encargaba de proteger su monopolio amenazando a cualquier otra
empresa que intentara clonar su sistema. Phoenix Technologies, decidió aplicar la técnica de la habitación
limpia, la cual consistía en tener dos grupos de ingenieros totalmente desvinculados, donde uno se encargaba
de estudiar en profundidad la BIOS de IBM para transmitírselo al segundo grupo, sin especificar detalles
técnicos o de código y que, por lo tanto, pudieran crear un sistema que se comportara de igual manera programada
desde cero. \cite{IngenieriaInversa}

En este caso, gracias a un sistema basado en la ingeniería inversa, se pudo crear un sistema que se comportaba
de la misma manera que el sistema de IBM, pero programado desde cero y, por lo tanto, acabar con el monopolio
de IBM, lo cual fue muy beneficioso para el mercado y para los consumidores.

Por lo que respecta a la legalidad de la ingeniería inversa, creo que es un tema más complejo y que depende
mucho de la legislación de cada país. En el caso de España, el Real Decreto Legislativo 1/1996, de 12 de abril,
por el que se aprueba el texto refundido de la Ley de Propiedad Intelectual, en su artículo 100, que establece
los límites de explotación de la obra, en su apartado 3\cite{LeyPropiedadIntelectual}: 

\begin{quote}
    \textit{``El usuario legítimo de la copia de un programa estará facultado para observar, estudiar o 
    verificar su funcionamiento, sin autorización previa del titular, con el fin de determinar las ideas
    y principios implícitos en cualquier elemento del programa, siempre que lo haga durante cualquiera de
    las operaciones de carga, visualización, ejecución, transmisión o almacenamiento del programa que tiene
    derecho a hacer''}
\end{quote}

Como se puede observar, la ley contempla que nosotros como usuarios podamos analizar e indagar en el funcionamiento
de un programa informático que legítimamente hemos adquirido y dentro de los términos de uso, es decir, aplicar
ingeniería inversa.

A pesar de que hay muchos casos a contemplar que se van fuera del objetivo de este trabajo y de muchas más leyes
que entran en juego a la hora de aplicar ingeniería inversa. Podemos concluir que mientras estos programas se hayan
adquirido legalmente, podremos aplicar ingeniería inversa sobre estos, siempre y cuando la finalidad no sea copiar,
sino entender el funcionamiento de un producto.

\section{Barreras de la ingeniería inversa}
\label{sec:barreras}

% Corregido 02/01/2024
% TODO:daniel: Revisar Barreras de la ingeniería inversa

Como he mencionado, la ingeniería inversa no es un proceso sencillo y requiere de muchas
habilidades y conocimientos para poder aplicarla. En este apartado, me gustaría introducir
las diferentes barreras a nivel técnico que nos podemos encontrar a la hora de aplicar
ingeniería inversa sobre un programa informático. \cite{alma991004951313206711}

\begin{enumerate}
    \item \textbf{Diferencia entre Dominio de la Aplicación y Lenguajes de Programación}
        
        Traducir de conceptos de dominio (que es lo que quiero que haga mi aplicación) a
        un lenguaje de programación concreto y viceversa es un reto complejo, es decir, mapear
        conceptos del comportamiento del código a conceptos de dominio.
    \item \textbf{Concreción y abstracción}
        
        Cuando nos enseñan a programar, nos enseñan a abstraernos de los detalles de implementación
        y a pensar en términos de conceptos abstractos. Por lo tanto, cuando aplicamos ingeniería
        inversa, tenemos que hacer el proceso inverso, es decir, concretar los conceptos abstractos
        a partir de detalles de implementación.
    \item \textbf{Decadencia de la Estructura del Sistema}
        
        Muchos sistemas informáticos, a lo largo del tiempo y con el mantenimiento, han ido perdiendo
        su estructura original, por lo tanto, a la hora de aplicar ingeniería inversa, nos podemos
        encontrar con que el sistema no tiene una estructura clara.
    \item \textbf{Disonancia Cognitiva}
        
        Los humanos pensamos en términos asociativos, mientras que los programas informáticos son expresiones
        jerárquicas formales. En consecuencia, supone un desafío a la hora de aplicar ingeniería inversa.
\end{enumerate}

\section{Fases de la ingeniería inversa}
\label{sec:fases}

% Corregido 02/01/2024
% TODO:daniel: Revisar Fases de la ingeniería inversa

Normalmente, la ingeniería inversa, cuando la queremos aplicar sobre programas informáticos, se divide en
cinco fases \cite{FasesIngineriaInversa}:

\begin{enumerate}
    \item \textbf{Recopilación de información}: esta fase consiste en recopilar toda la información posible
        sobre el programa que queremos analizar. Esta información puede ser desde el código fuente, la
        documentación, el manual de usuario, los binarios, etc.
    \item \textbf{Análisis estático}: una vez recopilada la información es hora de analizarla. En esta fase
        se analiza el código fuente, los binarios, la documentación, etc. El objetivo de esta fase es
        entender la estructura, el funcionamiento, la lógica y la organización interna del programa. Esta fase
        se caracteriza por no ejecutar el programa.
    \item \textbf{Análisis dinámico}: una vez hecho el análisis estático, es hora de ejecutar el programa
        y analizar su comportamiento. En esta fase se analiza el comportamiento del programa, como se comunica
        con el sistema operativo, como se comunica con otros programas, etc.
    \item \textbf{Desmontaje y decompilación}: para tener un análisis exhaustivo del programa, es necesario
        desmontar y descompilar el programa. El desmontaje consiste en obtener el código ensamblador del programa
        y la decompilación consiste en obtener el código fuente del programa.
    \item \textbf{Reconstrucción}: Esta etapa se hará en el caso de que sea necesario modificar el programa o
        mejorar la aplicación. Por ejemplo, en caso de detectar algún error durante las etapas anteriores, se
        puede modificar el programa para corregirlo.
\end{enumerate}

Cabe destacar, que en el contexto de este proyecto, el objetivo es poder automatizar o mejorar los resultados
de la fase de desmontaje y decompilación. Las otras fases son fases muy complejas y manuales que requieren
de una persona dedicada a ello.