\chapter{Justificación}
\label{cap:justificacion}

\section{Soluciones y alternativas existentes}
\label{sec:alternativas}

Actualmente, en el mercado podemos encontrar diferentes herramientas o programas llamados descompiladores o reversores los cuales tienen la capacidad de convertir un ejecutable
en un código C aproximado. Con aproximado me vengo a referir que el código que nos dan es más parecido a un pseudocódigo muy parecido a C, pero que necesitaría ciertos ajustes
por parte nuestra para que fuese más legible.

Así mismo, la mayoría de estas herramientas están más orientadas a la generación de un código ensamblador más "amigable" y que mayoritariamente siempre necesitara intervención
para que pueda ser más legible. También añadir que estas herramientas no utilizan inteligencia artificial para mejorar sus resultados.

Algunas de estas herramientas son:

\begin{itemize}
    \item \bf IDA Pro\footnote{Enlace a la pagina web del producto \href{https://hex-rays.com/ida-pro/}{IDA Pro}}
    \item \bf Ghidra\footnote{Enlace a la pagina web del producto \href{https://ghidra-sre.org/}{Ghidra}}
    \item \bf AllyDbg\footnote{Enlace a la pagina web del producto \href{https://www.ollydbg.de/}{AllyDbg}}
\end{itemize}

\subsection{IDA Pro}
\label{subsec:IDA_pro}

\begin{code}[h]
    \begin{lstlisting}[language=C++]
    #include <stdio.h>
    #include <stdlib.h>

    int maximo(int x, int y);

    int main(){
        int x=5,y=6,max;
        max=maximo(x,y); //Se pasa una copia de x & y, se guarda el retorno

        printf("El valor maximo es %i\n",max );

        system("pause");
        return 0;
    }

    int maximo(int a, int b){
        if(a>b)
            return a;
        else
            return b;
    }
    \end{lstlisting}
    \caption[Código de prueba con un método main y un método máximo]{Código de prueba con un método main y un método máximo (Elaboración propia)}
    \label{cod:codigo_prueba}
\end{code}
    

\section{Solucion tomada}
\label{sec:solucion}

% Corregido

La solución tomada pasa por investigar si el uso de inteligencia artificial, más concretamente el uso de modelos de lenguaje preentrenados, nos podría ayudar a la hora de hacer
ingeniería inversa sobre un programa en su forma de ejecutable u objeto.

Para poder hacerlo se decide utilizar modelos de lenguaje disponibles en Internet que la propia comunidad de desarrollo de software libre ha creado o modelos liberados por Microsoft.
La intención es aplicar \textit{fine-tuning} sobre estos modelos ya preentrenados, de tal manera que podemos aumentar la calidad de los resultados obtenidos para nuestra
tarea específica.

Así mismo, se tendrá que investigar sobre que método de \textit{fine-tuning} podemos utilizar, que se ajuste más a la características de nuestra tarea, teniendo en cuenta cosas como el
tipo de datos que se utilizan y el resultado que se quiere obtener.
