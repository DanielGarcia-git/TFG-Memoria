\chapter{Justificación}
\label{cap:justificacion}

En este capitulo detallare las soluciones que hay disponibles para el problema descrito en sección \ref{sec:problema}. Ademas, detallare la solución tomada en este proyecto
y porque esta solución podria dar mejores resultados que los que dan las herramientas actuales.

\section{Soluciones y alternativas existentes}
\label{sec:alternativas}

Actualmente, en el mercado podemos encontrar diferentes herramientas o programas llamados descompiladores o reversores los cuales tienen la capacidad de convertir un ejecutable
en un código C aproximado llamado normalmente por estas herramiento como pseudocódigo.

Así mismo, la mayoría de estas herramientas están más orientadas a la generación de un código ensamblador más "amigable" y que mayoritariamente siempre necesitara intervención
para que pueda ser más legible y asi ayudar en procesos de depuración.

Algunas de estas herramientas son:

\begin{itemize}
    \item \bf IDA Pro\footnote{Enlace a la página web del producto \href{https://hex-rays.com/ida-pro/}{IDA Pro}}
    \item \bf Ghidra\footnote{Enlace a la página web del producto \href{https://ghidra-sre.org/}{Ghidra}}
    \item \bf AllyDbg\footnote{Enlace a la página web del producto \href{https://www.ollydbg.de/}{AllyDbg}}
\end{itemize}

En la proxima sección detallaremos un poco mas la herramienta IDA Pro en su vertiente gratuita llamda IDA Free\footnote{Enlace a la página web del producto \href{https://hex-rays.com/ida-free/}{IDA Free}},
ya que esta es la más usada para aplicar ingeniería inversa.

\subsection{IDA Pro}
\label{subsec:IDA_pro}

IDA o \textit{Interactive Disassembler} es un desensamblador que es utilizado para ingeniería inversa. IDA soporta una variedad de formato de ejecutables para diferentes procesadores y
sistemas operativos. Tambien es usado como depurador para ejecutables del tipo Windows PE, Mac OS X, Mach-O y Linux ELF\cite{IDAPro_Wikipedia}. Aunque nativamente IDA no teine decompilador, 
en sus ultimas versiones dispones de un \textit{plugin} que nos brinda esta funcionalidad. Cabe destacar que este plugin es un decompilador basado en \textit{cloud}, es decir requiere
de conexión a internet para poder generar un pseudocódigo a partir de un ejecutable.

Para poder analizar en mas profundidad esta herramienta he hecho diferentes pruebas con codigos muy sencillas para poder comprobar que tipo de solucion nos da esta herramienta. Para ello
he utilizado el codigo \ref{cod:binarySearch}, donde se oberva la implementación del algoritmo de busqueda binaria en código C.

\begin{code}
    \begin{minted}{c}
    /** Recursive implementation
    * \param[in] arr array to search
    * \param l left index of search range
    * \param r right index of search range
    * \param x target value to search for
    * \returns location of x assuming array arr[l..r] is present
    * \returns -1 otherwise
    */
    int binarysearch1(const int *arr, int l, int r, int x)
    {
        if (r >= l)
        {
            int mid = l + (r - l) / 2;

            // If element is present at middle
            if (arr[mid] == x)
                return mid;

            // If element is smaller than middle
            if (arr[mid] > x)
                return binarysearch1(arr, l, mid - 1, x);

            // Else element is in right subarray
            return binarysearch1(arr, mid + 1, r, x);
        }

        // When element is not present in array
        return -1;
    }

    /** Iterative implementation
    * \param[in] arr array to search
    * \param l left index of search range
    * \param r right index of search range
    * \param x target value to search for
    * \returns location of x assuming array arr[l..r] is present
    * \returns -1 otherwise
    */
    int binarysearch2(const int *arr, int l, int r, int x)
    {
        int mid = l + (r - l) / 2;

        while (arr[mid] != x)
        {
            if (r <= l || r < 0)
                return -1;

            if (arr[mid] > x)
                // If element is smaller than middle
                r = mid - 1;
            else
                // Else element is in right subarray
                l = mid + 1;

            mid = l + (r - l) / 2;
        }

        // When element is not present in array
        return mid;
    }
    \end{minted}
    \captionof{listing}[Búsqueda binaria, iterativa y recursiva]{Búsqueda binaria, iterativa y recursiva (\cite{BinarySearchGitHub})}
    \label{cod:binarySearch}
\end{code}

Compilamos el código y con el ejecutable que nos genera se lo damos a IDA Free y utilizando el plugin de decompilacor basado en \textit{cloud} generamos un pseudocódigo de los metodos
que encontramos en el código \ref{cod:binarySearch}. En la figura \ref{fig:IDAPro_binaryseacrh1} podemos observar la funcion \textit{binarysearch1()} y en la figura \ref{fig:IDAPro_binaryseacrh2}
podemos observar la funcion \textit{binarysearch2()}.

\begin{figure} [h!]
    \begin{center}
      \includegraphics[width=15cm]{figuras/Capitulo_2/Cap_2_IDAPro_binaryseacrh1.png}
    \end{center}
    \caption[Captura de pantalla de IDA Free con el pseudocódigo generado para la funcion \textit{binaryseacrh1}]{Captura de pantalla de IDA Free con el pseudocódigo generado para la funcion \textit{binaryseacrh1} (Elaboración propia)}
    \label{fig:IDAPro_binaryseacrh1}
\end{figure}\

\begin{figure} [h!]
    \begin{center}
      \includegraphics[width=15cm]{figuras/Capitulo_2/Cap_2_IDAPro_binaryseacrh2.png}
    \end{center}
    \caption[Captura de pantalla de IDA Free con el pseudocódigo generado para la funcion \textit{binaryseacrh2}]{Captura de pantalla de IDA Free con el pseudocódigo generado para la funcion \textit{binaryseacrh2} (Elaboración propia)}
    \label{fig:IDAPro_binaryseacrh2}
\end{figure}\

\section{Solucion tomada}
\label{sec:solucion}

Una vez visto en la sección \ref{sec:alternativas} las diferentes alternativas que hay en el mercado para poder aplicar ingeniería inversa sobre fichero ejecutables y observado que los
resultados obtenidos no son un código en C compilable y realista, quiero explicar cual es la solución que en este proyecto se desarrollara.

El objetivo es a traves de un ejecutables desamblado poder generar un copdigo en C compilable y lo mas fiel al original. Para ello queremos de asistirnos de la inteligencia artifical
de tal manera que si le damos un codigo desamblado esta nos pueda devolver un codigo en C. Mas concretamente, queremos utilizar inteligencias artificiales basadas en redes neuronales
del estilo de ChatGPT\footnote{ChatGPT es una aplicación de chatbot de inteligencia artificial desarrollado en 2022 por OpenAI que se especializa en el diálogo} o modelos similares
como Llama\footnote{LLaMA (Large Language Model Meta AI) es un gran modelo de lenguaje (LLM) lanzado por Meta AI en febrero de 2023}.

Por lo tanto, lo que se pretende en esta solución es poder mejorar los resultados de decompiladores que hay en el mercado asistiendonos con inteligencia artifical, la cual a demostrado
que a pesar de haber sido entrenadas para hacer una unica tarea en concreto (los modelos anteriores por ejemplo, han sido entrenados exclusivamente para completar frases) son capaces de
realizar otro tipo de tareas a las cuales no han sido entrenadas y con resultados bastante buenos. Ademas¡,e stan pueden ser re-entrenadas para mejorar los resultados.
